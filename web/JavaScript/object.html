<html>
    <body>
        <h1>Array & Object</h1>
        <script>
            // 자바스크립트 배열 []
            // 한건 한건의 데이터는 배열에 담습니다.

            let topics = ['html', 'css', 'js']; // 1 차원 데이터
            document.write(topics[0]+'<br>');
            document.write(topics[1]+'<br/>');

            // 책 아이디 1 제목 html . 'html is....'
            // 자바스크립트 객체 {}
            // 하나의 데이터에 대한 속성들의 모임은 객체에 담습니다.
            let topic1 = {id:1, title:'html', body:'html is ../'}
            document.writeln(topic1.id);
            document.writeln(topic1.title)
            document.writeln(topic1.body+'<br>');

            let topic2 = {id:2, title:'css', body:'CSs is ...'}

            let topics2  = [topic1, topic2];

            document.write(topics2[0].title+'<br>')
        </script>
        <h1>Function</h1>
        <script>
            let a = 1;
            let b = [1,2];
            // let c = if(1==1{}조건문은 first citizen이 아니다)
            
            // 익명함수 에게는 변수를 줄수 잇음 (함수는 값이 될 수 있음)
            // => 배열이나 객체에 원자가 될 수 있음
            /*
            function(){

            }
            */
            let c = function(){document.write('c')}
            
        </script>
        <h1>Function & Object</h1>
        <script>
            // 데이터와 데이터를 처리하는 함수가 분리 되어 있어서 여러 문제가 발생한다.
            let topics3 =[{id:1, title:'html', body:'html is ..'},
                        {id:2, title:'css', body:'css is..'}
                    ]
                    //1억줄
            function read1(){
                document.write('read1')
            }
            read1();
            // 데이터와 함수를 같은 바구니에 담고 싶다.
            let topic4 = [
                { id: 1, title: 'html', body: 'html is ..', read:function(){
                    document.write(this.title + '=>' + this.body+'<br>')
                }}
            ]
            topic4[0].read();


            // built-in
            document.write(Math.PI+'<br>');
        </script>
    </body>
</html>